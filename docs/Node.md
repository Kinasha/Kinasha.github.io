## 异步请求

发请求一直是我不太会的事情，`async await` `then` 这些在我看来像天书一样。而普通的业务前端没有接口，又没办法自行测试学习。
最近发现了一个联系发送异步请求的好方法—— 用 apifox mock 数据，然后在 node 里面发请求

![](https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/25599243657/b602/01fd/a082/ffd24127d9ddf0499296bd022e390726.png)

# Node

## 模块化

- 模块化是每种高级语言都应该具备的能力，类似 Java 中 `包` 的概念，目的是能够更好地复用轮子。
- JS 原生没有提供模块化的解决方案，在前端发展的过程中，多种模块化的方案各显神通。最终，ES 规范组织制定了 ES6 模块方案，我认为是未来的主流。

node 默认情况下是 `CommonJS` 规范，但新版本的 Node 已经支持 `ES6 模块`规范，可以通过在 `package.json` 配置文件中 指定`type` 为 `module` 或者使用 `.mjs` 作为 js 文件的拓展名，从而开启 `ES6模块` 特性

> 常见的模块化解决方案
>
> | 方案名称 | 代表实践   | 备注                                                                                  |
> | -------- | ---------- | ------------------------------------------------------------------------------------- |
> | IIFE     | jQuery     | 通过立即执行函数向全局变量 window 注入自己的设计的 api，有命名冲突的风险              |
> | AMD      | require.js | 基本不用                                                                              |
> | CMD      | Sea.js     | 基本不用                                                                              |
> | CommonJS | node       | 服务端（非浏览器环境下）的模块化方案，使用方法 module.exports = {} 搭配 require()     |
> | UMD      |            | 兼容以上多种方案的缝合怪，基本思路就是判断 **可用性**                                 |
> | ES6 模块 |            | 真正的大一统，官方推出的语言层面的模块化方案，用 import export ，咱 js 村里终于通电了 |

**Node 中具体是如何实现模块化呢？**

首先，Node 将模 C:\Users\asus-pc\Desktop\project_for_test\package.json C:\Users\asus-pc\Desktop\project_for_test\src\index.js C:\Users\asus-pc\Desktop\project_for_test\src\index.htm 块分为两种——核心模块和文件模块

| 核心模块                                                   | 文件模块                                                |
| ---------------------------------------------------------- | ------------------------------------------------------- |
| 由 node 提供，启动时已经编译为二进制加载进内存，速度非常快 | 由用户编写，要经过 路径分析、文件定位、编译执行三个阶段 |

- 路径分析

  前文提到核心模块已被加载进内存，无需路径分析、对于文件模块，根据向 require 传入的是**路径**或者**标识符**分为两种情况

  - 路径
    - 无论是绝对路径还是相对路径，都会被转化成为真实路径，并将结果放到缓存中，方便下次加载
  - 标识符
    - 类似作用域链、查找顺序为**当前目录的 node_modules** ➡ **父级目录的 node_modules** ➡ **递归向上直至根目录** 。肉眼可见，这种情况耗时最长。

- 文件定位

  - **.js** ➡ **.json**➡ **.node**
  - 如果有 **package.json** 就会从`main` 指定的文件入口开始查找

- 编译执行

  - 值得注意的是，一旦被执行过，这些模块就会被加载进缓存，下次直接从缓存中查找，不在进行这一老长串流程。
