# Node


## 模块化

- 模块化是每种高级语言都应该具备的能力，类似Java中 `包` 的概念，目的是能够更好地复用轮子。
- JS原生没有提供模块化的解决方案，在前端发展的过程中，多种模块化的方案各显神通。最终，ES规范组织制定了ES6 模块方案，我认为是未来的主流。

node 默认情况下是 `CommonJS` 规范，但新版本的Node已经支持 `ES6 模块`规范，可以通过在 `package.json` 配置文件中 指定`type` 为 `module` 或者使用 `.mjs` 作为js文件的拓展名，从而开启 `ES6模块` 特性

>常见的模块化解决方案
>
>| 方案名称 | 代表实践   | 备注                                                         |
>| -------- | ---------- | ------------------------------------------------------------ |
>| IIFE     | jQuery     | 通过立即执行函数向全局变量window注入自己的设计的api，有命名冲突的风险 |
>| AMD      | require.js | 基本不用                                                     |
>| CMD      | Sea.js     | 基本不用                                                     |
>| CommonJS | node       | 服务端（非浏览器环境下）的模块化方案，使用方法 module.exports = {} 搭配 require() |
>| UMD      |            | 兼容以上多种方案的缝合怪，基本思路就是判断 **可用性**        |
>| ES6 模块 |            | 真正的大一统，官方推出的语言层面的模块化方案，用import export ，咱js村里终于通电了 |

**Node 中具体是如何实现模块化呢？**

首先，Node将模C:\Users\asus-pc\Desktop\project_for_test\package.json C:\Users\asus-pc\Desktop\project_for_test\src\index.js C:\Users\asus-pc\Desktop\project_for_test\src\index.htm块分为两种——核心模块和文件模块

| 核心模块                                                   | 文件模块                                                |
| ---------------------------------------------------------- | ------------------------------------------------------- |
| 由 node 提供，启动时已经编译为二进制加载进内存，速度非常快 | 由用户编写，要经过 路径分析、文件定位、编译执行三个阶段 |

- 路径分析

  前文提到核心模块已被加载进内存，无需路径分析、对于文件模块，根据向require传入的是**路径**或者**标识符**分为两种情况

  - 路径
    - 无论是绝对路径还是相对路径，都会被转化成为真实路径，并将结果放到缓存中，方便下次加载
  - 标识符
    - 类似作用域链、查找顺序为**当前目录的node_modules** ➡ **父级目录的node_modules** ➡ **递归向上直至根目录** 。肉眼可见，这种情况耗时最长。

- 文件定位

  - **.js** ➡  **.json**➡ **.node**
  - 如果有 **package.json** 就会从`main` 指定的文件入口开始查找

- 编译执行

  - 值得注意的是，一旦被执行过，这些模块就会被加载进缓存，下次直接从缓存中查找，不在进行这一老长串流程。

